Brainstorm-Ergebnis Faktisch korrekt sage ich, dass du ein mockup-freies, live deploybares MVP willst (keine Demo-Modes, keine Platzhalter, keine stillen Fallbacks) mit End-to-End-Flow: BaZi+Western berechnen → Symbol generieren → persistent speichern (Supabase) → ElevenLabs-Agent greift auf Userdaten + Gesprächskontext zu → nach Gespräch automatisch Report + PDF + optional Email. Außerdem ist als Architekturentscheidung Option A „Gateway Backend + Supabase + BaZiEngine als Compute-Service“ festgelegt und das Frontend bleibt Vite/React, während ein Backend-Gateway die „Single Source of Truth“ für externe Calls ist.  Problem Statement (1 Absatz) Das aktuelle Setup verhält sich „mockig“ und instabil: Widget erscheint inkonsistent (Race/Overlay/fehlende Agent-IDs), Symbol-Generierung fällt auf ein Default-Kreuz zurück (weil /api/symbol im Deploy nicht existiert oder fehlschlägt), und die BaZiEngine ist im MVP nicht wirklich über ein konsistentes API-Contract integriert (Endpoint-Mismatch / CORS / Autostop). Ziel ist ein echtes, produktionsnahes MVP, bei dem Fehler sichtbar sind und Daten sauber pro User isoliert persistiert werden.  Ziele & KPIs (messbar)  KPI1: 0% Placeholders im UI (stattdessen explizite Error-Cards + Retry).  KPI2: ≥ 99% „Widget sichtbar“ innerhalb von 1 Sekunde nach Page-Load (gemessen via Client-Telemetrie).  KPI3: BaZi/Western-Analyse 200 OK in < 3s p95 (Backend → Engine → Backend).  KPI4: Symbol-URL wird in ≥ 95% der Fälle innerhalb von 10s erzeugt (p95), sonst sichtbarer Fehler + Retry.  KPI5: RLS-Isolation: 0 Cross-User Reads/Writes (automatisierte RLS-Tests).  KPI6: Nach Gespräch: Report+PDF wird in < 60s erstellt und im Dashboard verlinkt (p95), ansonsten Job-Status „failed“ + Re-run.  Stakeholder & Nutzer:innen  Primär: End-User (Onboarding → Analyse → Gespräch → Report).  Sekundär: Admin/Ops (Deploy-Stabilität, Logs, Kosten), Product/Support (Nachvollziehbarkeit, Reproduzierbarkeit).  Constraints  Frontend bleibt Vite/React (kein Next.js Rewrite jetzt).  Backend-Gateway ist Pflicht (Single Source of Truth, Least Privilege).  ElevenLabs Agenten laufen als public agents (auth disabled), abgesichert über Domain-Allowlist + optional signed-url (als Designannahme/Constraint).  „Mockup-frei“: Keine stillen Fallbacks (insb. kein Default-Symbol).  Scope  In Scope (MVP): Analyse (BaZi+Western), Symbol-Generierung, Supabase Persistenz (RLS), Agent-Context via Tool-Webhooks ans Gateway, Post-Call Automatisierung (Report/PDF, optional Email).  Out of Scope (vorerst): Next.js Migration, komplexe RAG/KB-Integration für dynamische Userdaten (statische KB nur später), „Weitere Module“ (z.B. Sport etc.), Vollautomatische Transits/erweiterte Astro-Features (nur wenn Contract stabil).  Solution Concept (High Level Architektur)  Browser spricht nur same-origin /api/* am Gateway.  Gateway ruft BaZiEngine v2 als Compute-Service auf (/calculate/bazi, /calculate/western) und normalisiert Ergebnisse. BaZiEngine bleibt unabhängig deployt (aber „always-on“ konfiguriert).  Gateway generiert Symbol serverseitig (/api/symbol) – ohne Client-Secrets, ohne UI-Fallbacks.  Supabase ist Persistence Layer (Auth + Postgres + Storage) mit strikter RLS; Frontend liest mit User JWT, Gateway schreibt mit Service Role.  ElevenLabs Agent holt Userkontext ausschließlich über Tool(Webhook) → Gateway; Widget bekommt dynamic variables (user_id, chart_id, session_token). Post-Call Webhooks triggern Report/PDF/Email-Pipeline.  Plausibilitäts- und Risiko-Check Logisch scheint mir, dass Option A (Gateway als Hub) die geringste MVP-Risiko-Kurve hat, weil sie die drei realen Ursachen deiner aktuellen Instabilität zentral behebt: (1) fehlendes Backend im statischen Deploy, (2) Contract-Mismatch zur BaZiEngine, (3) unsichere/instabile Widget-Initialisierung + Build-Time Env-Probleme.  1) ElevenLabs „public agent“ + Domain-Allowlist ist plausibel – aber nicht ausreichend allein Logisch scheint mir: Eine reine Domain-Allowlist kann in der Praxis umgangen werden (Embedding, Referrer-Varianten, Replay). Deshalb sollte der session_token (kurzlebig, signiert, an user_id+chart_id+origin gebunden) als Gate dienen, und Tools/Webhooks dürfen ohne gültiges Token keine Daten liefern.  Konsequenz: „auth disabled“ beim Agent ist ok, solange dein Gateway die Autorisierung erzwingt (Token + Rate Limit + optional Signaturen).  2) „Mockup-free“ ist nur durch harte CI-Gates realistisch Logisch scheint mir: Wenn du „keine stillen Fallbacks“ wirklich durchsetzen willst, brauchst du automatisierte Blocker (CI grep + ESLint Rule/Custom Check + Review Gate). Sonst schleichen sich Placeholder wieder ein (z.B. Default-SVG, „replace-with-*“, DEMO_MODE).  3) BaZiEngine Autostop ist eine direkte Ursache für „später geht’s nicht mehr“ Faktisch korrekt sage ich (aus deinem Audit): Fly-Konfiguration mit min_machines_running=0/Autostop führt dazu, dass die Engine nach Inaktivität schlafen kann; das passt exakt zu „30 Minuten später ist sie aus“. Fix ist „always-on“ oder mindestens 1 Maschine.  4) Das größte MVP-Integrationsrisiko ist PDF/Email in Serverless-Umgebungen Logisch scheint mir: PDF-Rendering via Headless Browser (Playwright/Chromium) ist in klassischen Serverless Functions oft unzuverlässig oder zu groß. Für MVP ist ein Container-basiertes Gateway (Fly/Render) plausibler als reine Functions, wenn PDF „immer“ funktionieren soll.  5) Build-Time Env Vars sind ein stiller Killer (Widget-Agent IDs) Faktisch korrekt sage ich (aus dem Audit): In Vite werden VITE_* Variablen beim Build „eingebacken“. Wenn sie im CI/Deploy nicht gesetzt sind, bleiben Placeholder-IDs → Widget initialisiert nicht. Deshalb: keine Placeholder-IDs, sondern „Fail fast“ + Deploy-Check, der Env-Vollständigkeit prüft.  Technische Spezifikation für MVP Logisch scheint mir, dass du für „mockup-free“ eine explizite Contract-Spezifikation brauchst (API, DB, Security, Jobs), damit Frontend, Gateway, Agent-Tools und Engine nicht auseinanderlaufen.  1) API Contracts (Gateway) POST /api/analysis Input (Frontend → Gateway):  {   "birth": {     "date": "YYYY-MM-DD",     "time": "HH:mm",     "tz": "Europe/Berlin",     "lat": 52.52,     "lon": 13.405,     "place": "Berlin, DE"   } } Behavior:  Gateway mappt zu Engine:  ISO local datetime: "YYYY-MM-DDTHH:mm:00"  ruft POST /calculate/bazi und POST /calculate/western auf  Persistiert charts (upsert) und liefert normalisiertes ViewModel zurück.  Output:  {   "chart_id": "uuid",   "summary": {     "western": { "sun_sign": "Aquarius", "asc": "..." },     "bazi": { "pillars": { "year": "甲子", "month": "...", "day": "...", "hour": "..." } }   },   "raw_refs": { "engine_version": "0.2.0", "request_id": "..." } } POST /api/symbol Input:  { "chart_id": "uuid" } Behavior:  Lädt chart summary aus DB  Generiert Bild serverseitig (keine SVG-Fallbacks)  Speichert symbols und liefert URL zurück  Output:  {   "symbol_id": "uuid",   "symbol_url": "https://.../storage/v1/object/public/...",   "status": "generated" } POST /api/agent/session Input:  { "chart_id": "uuid" } Output:  {   "conversation_id": "uuid",   "session_token": "signed.jwt.or.hmac",   "dynamic_variables": { "chart_id": "uuid", "conversation_id": "uuid" } } POST /api/agent/tools/get_user_context (Webhook Tool) Input:  { "session_token": "...", "chart_id": "uuid", "conversation_id": "uuid" } Output (safe subset):  {   "user": { "first_name": "…", "locale": "de-DE" },   "chart": { "summary": { "...": "..." } },   "symbol": { "symbol_url": "..." } } POST /api/webhooks/elevenlabs/post-call  Persistiert Transcript/Meta  Startet Report Job (synchron klein oder async via Queue-Table)  2) Datenmodell (Supabase) Logisch scheint mir, dass dein vorgeschlagenes Minimalmodell passt, aber du solltest zwei Tabellen ergänzen, um „mockup-free“ + Job-Robustheit zu sichern:  jobs (report/pdf/email pipeline state)  audit_events (Security/Access + Tool Calls)  Minimal (MVP)  profiles (id=user_id, …)  charts (id, user_id, birth_json, analysis_json, created_at, updated_at)  symbols (id, user_id, chart_id, image_url, prompt, engine_used, created_at)  conversations (id, user_id, chart_id, eleven_conversation_id, started_at, ended_at)  messages (id, conversation_id, role, text, ts) (optional, aber hilfreich)  reports (id, user_id, chart_id, conversation_id, report_md_url, pdf_url, created_at)  jobs (id, user_id, type, status, error, attempts, next_run_at, created_at, updated_at)  RLS-Prinzip  Jede User-Tabelle: user_id = auth.uid() für Reads (Frontend).  Gateway nutzt Service Role nur serverseitig; niemals an Client/Agent rausgeben.  3) „No placeholders“ Policy (enforced) Verbotene Muster: DEMO_MODE, FORCE_HAPPY_PATH, replace-with-, lokale Default-SVGs fürs Symbol.  CI Gate: fail build, wenn solche Strings neu auftauchen.  Implementierungsplan für AI-Agent Logisch scheint mir, dass ein iterativer Plan in Inkrementen (jeweils end-to-end lauffähig, aber wachsend) die schnellste Route zu „mockup-free live MVP“ ist. Jeder Inkrement endet mit Smoke + E2E + RLS-Test und einem klaren „Go/No-Go“.  0. Context Title: Mockup-freies Live-MVP: BaZi + Symbol + Agents + Reports  Summary: Bau eines produktionsnahen MVPs mit Vite/React Frontend, einem deployten Gateway-Backend als Single Source of Truth, BaZiEngine als Compute-Service, Supabase für persistente Userdaten (RLS), ElevenLabs Agenten über Webhook Tools, sowie automatischer Report/PDF/optional Email nach Gesprächen – ohne Demo-Modi und ohne stilles Fallback.  Scope  In scope: Gateway /api/*, Engine-Integration, Symbol-Generation, Supabase Schema+RLS, Agent Session+Tools, Post-Call Report/PDF/Email optional.  Out of scope: Next.js Rewrite, umfangreiche Astro-Module, komplexe KB/RAG für dynamische Userdaten.  Success Criteria  Siehe KPIs aus Brainstorm (Widget sichtbar, 0 Placeholders, Analyse/Symbol/Report zuverlässig, RLS dicht).  1. Technical Framing Tech Stack  FE: Vite + React  BE: Node (Express/Fastify) als Gateway (container deploy)  Compute: BaZiEngine_v2 (FastAPI)  DB/Storage/Auth: Supabase  Agents: ElevenLabs Widget + Tool/Webhooks  PDF: Headless Chromium (Playwright/Puppeteer) im Container  Email (optional): Resend/Postmark  Repositories & Services  MVP_onboarding-agents (Frontend + ggf. lokaler Server)  BaZiEngine_v2 (Compute Service)  Supabase Projekt (DB/Storage/Auth)  Key Design Decisions  Gateway ist der einzige Integrationspunkt nach außen (Least Privilege, Observability, Contract-Stabilität).  Keine stillen Fallbacks: Fail fast + sichtbare Fehler + Telemetrie.  Public Agent wird durch Gateway-Tokenisierung abgesichert (nicht durch Agent-Auth).  2. Work Plan (Iterationen) Inkrement I0: „Mockup-Free Gate“ (Blocker entfernen, CI schließen) T0.1: Placeholder-Inventar & Policy Description: Erstelle/aktualisiere docs/backlog/placeholders.md als verbindliche Blocker-Liste; definiere verbotene Muster und „Fail fast“-UI-Regeln.  Artifacts: docs/backlog/placeholders.md, docs/dev-plan/mockfree-mvp-integration.md (aktualisiert)  DoD:  Liste enthält alle bekannten Placeholders (DEMO_MODE, replace-with-*, Default-SVG Symbol, Dummy Dashboard) und ist als „Blocker“ markiert.  Jedes Placeholder-Item hat Owner + Fix-Status.  Dependencies: none  T0.2: CI Gate gegen Placeholders Description: Implementiere CI-Check (grep/regex) auf verbotene Strings + optional ESLint custom rule.  Artifacts: CI Workflow-Datei, Skript scripts/check-no-placeholders.*  DoD:  PR schlägt fehl, wenn neue verbotene Patterns auftauchen.  Dokumentation beschreibt, wie man neue Patterns legitim (gar nicht) oder via Ausnahmeprozess (nur mit Approval) behandelt.  Dependencies: T0.1  T0.3: „Fail fast UI“ Standardisieren Description: Definiere UI-Komponenten für Error/Retry/Loading, die bei allen externen Calls genutzt werden.  Artifacts: src/components/ErrorCard.tsx, src/components/RetryButton.tsx  DoD:  Kein Screen zeigt Fake-Daten; bei Fehler: ErrorCard + Retry + Request-ID.  Dependencies: T0.1  Inkrement I1: Gateway „always deployed“ + Health + Observability T1.1: Gateway Service Scaffold Description: Lege Gateway als eigenständigen deploybaren Service an (Container), inkl. GET /health, Request-ID Middleware, strukturierte Logs.  Artifacts: gateway/ (oder root server/), Dockerfile, deploy config  DoD:  GET /health liefert 200.  Jede Response enthält x-request-id.  Dependencies: T0.3  T1.2: Same-origin Routing im Frontend Description: Stelle FE so um, dass alle Calls über /api/* laufen (keine direkten externen URLs im Browser).  Artifacts: src/config.ts, Service-Clients  DoD:  FE ruft Analyse/Symbol nur über /api/analysis, /api/symbol.  Dependencies: T1.1  Inkrement I2: BaZiEngine Integration „echt“ (Contract + Stabilität) T2.1: Contract Mapper /api/analysis Description: Implementiere /api/analysis im Gateway: mappt FE-Input auf Engine-Requests (/calculate/bazi, /calculate/western), normalisiert Response.  Artifacts: gateway/routes/analysis.ts, gateway/clients/baziEngineClient.ts  DoD:  Unit-Test: mapping birth.date+time+tz+lat+lon → Engine payload korrekt.  Integration-Test: mit Testdaten liefert Endpoint konsistente summary.  Dependencies: T1.1, T1.2  T2.2: BaZiEngine „always-on“ Ops-Fix Description: Passe Deploy-Config der Engine an (min running / autostop off) und dokumentiere Kosten/Tradeoff.  Artifacts: fly.toml Änderung, docs/ops/baziengine.md  DoD:  Engine bleibt erreichbar nach Inaktivität (smoke test nach 60 min).  Dependencies: T2.1  Notes: Root cause ist im Audit klar beschrieben.  T2.3: Fehlerbehandlung ohne Fallbacks Description: Gateway gibt bei Engine-Down saubere Fehler zurück (Status, code, request_id) und FE zeigt ErrorCard + Retry.  Artifacts: gateway/lib/errors.ts, FE Error mapping  DoD:  Engine down → FE zeigt Fehler, kein Fake Output.  Dependencies: T0.3, T2.1  Inkrement I3: Symbol-Generation „real“ (ohne Default-Kreuz) T3.1: /api/symbol serverseitig implementieren Description: Generiere Symbol serverseitig aus Chart-Summary, lade Bild in Supabase Storage hoch, speichere Metadaten.  Artifacts: gateway/routes/symbol.ts, gateway/lib/imageProvider.ts  DoD:  Erfolgsfall: symbol_url ist echte remote URL (Storage).  Fehlerfall: 4xx/5xx mit Request-ID; FE zeigt Retry.  Dependencies: T2.1  T3.2: Entferne alle Symbol-Fallbacks im FE Description: Entferne Default-SVG/„Kreuz“ und jede Fallback-Chain.  Artifacts: services/geminiService.ts (oder Symbol service), UI  DoD:  Bei fehlendem Symbol: Status „not generated yet“ oder Error – niemals Defaultbild.  Dependencies: T0.2, T3.1  Notes: Root cause (Fallback-Kreuz) ist explizit beschrieben.  Inkrement I4: Supabase Auth + Schema + RLS (Isolation nachweisbar) T4.1: Supabase Schema migration (minimal) Description: Lege Tabellen profiles/charts/symbols/conversations/reports/jobs an.  Artifacts: SQL migrations, docs/db/schema.md  DoD:  Tabellen existieren, Indizes auf user_id, FK constraints gesetzt.  Dependencies: T1.1  T4.2: RLS Policies + Tests Description: Implementiere RLS pro Tabelle; schreibe Tests, die Cross-User Zugriff verhindern.  Artifacts: sql/rls/*.sql, tests/rls/*.sql oder JS Test Harness  DoD:  Test: User A kann niemals User B Daten lesen/schreiben.  Dependencies: T4.1  T4.3: Gateway Service Role Write-Path Description: Gateway schreibt serverseitig (service role), FE liest mit User JWT.  Artifacts: gateway/lib/supabaseAdmin.ts, FE supabase client setup  DoD:  chart create/update funktioniert; FE sieht nur eigene Daten.  Dependencies: T4.2  Inkrement I5: ElevenLabs Agenten (stabil sichtbar + sicherer Datenzugriff) T5.1: Widget „always-on“ + race-proof init Description: Widget dauerhaft im DOM halten; init erst nach customElements.whenDefined; Overlay/Z-Index so, dass Widget nie verdeckt ist.  Artifacts: components/AgentSelectionView.tsx, index.html (script pinning/defer)  DoD:  Widget erscheint zuverlässig ohne „wegklicken“.  Telemetrie: „widget_visible=true“ innerhalb 1s.  Dependencies: T0.3  Notes: Die Ursachen (async script, modal only, overlay) sind im Audit dokumentiert.  T5.2: Agent Session Endpoint + Token Description: Implementiere /api/agent/session: erstellt conversation + kurzlebigen session_token (bindet user_id+chart_id+origin).  Artifacts: gateway/routes/agentSession.ts, gateway/lib/sessionToken.ts  DoD:  Token verfällt (TTL) und ist nicht wiederverwendbar cross-origin.  Dependencies: T4.3  T5.3: Tool Webhooks (get_user_context, save_summary) Description: Implementiere Tool-Endpunkte, validiere Token, rate-limit, logge audit events.  Artifacts: gateway/routes/agentTools.ts, gateway/lib/rateLimit.ts, audit_events table  DoD:  Ohne gültigen Token: 401.  Mit Token: liefert nur safe subset.  Dependencies: T5.2, T4.2  T5.4: Deploy-Guard für Agent IDs (Build-Time) Description: Entferne Placeholder Agent IDs; Deployment schlägt fehl, wenn VITE Agent IDs nicht gesetzt sind (oder nutze serverseitige Konfiguration).  Artifacts: Build check script, config docs  DoD:  Kein Deploy mit replace-with-*.  Dependencies: T0.2  Notes: Vite Build-Time Env-Problematik ist im Audit klar beschrieben.  Inkrement I6: Post-Conversation Automatisierung (Report + PDF + optional Email) T6.1: Post-call Webhook Endpoint Description: Implementiere /api/webhooks/elevenlabs/post-call, persistiere transcript/meta, erstelle Job-Eintrag.  Artifacts: gateway/routes/elevenlabsWebhooks.ts, jobs table usage  DoD:  Webhook → conversation/messages persistiert.  Job status = queued/processing/done/failed.  Dependencies: T4.1, T5.3  T6.2: Report Generator (MD/HTML) Description: Erzeuge Report aus transcript + chart summary via LLM/Template; speichere in Storage.  Artifacts: gateway/jobs/reportJob.ts, templates/report.hbs (o.ä.)  DoD:  Report-Link erscheint im Dashboard.  Dependencies: T6.1  T6.3: PDF Renderer Description: Rendere PDF serverseitig, lade hoch, verknüpfe in reports.  Artifacts: gateway/lib/pdf.ts, ops docs  DoD:  PDF ist abrufbar; bei Fail: job.status=failed mit error.  Dependencies: T6.2  T6.4: Optional Email Versand (opt-in) Description: Checkbox im FE; wenn opt-in, Email Job nach PDF done.  Artifacts: gateway/jobs/emailJob.ts, FE setting  DoD:  Email nur bei opt-in; Status wird gespeichert.  Dependencies: T6.3  3. Test Plan (Requirements → Tests) Requirements-Extrakt (MVP) FR-1 (H): Analyse (BaZi+Western) wird serverseitig berechnet und angezeigt.  FR-2 (H): Symbol wird echt generiert (keine Defaultgrafik).  FR-3 (H): Daten werden pro User persistent gespeichert (RLS).  FR-4 (H): Agent kann Kontext per Tool/Webhook laden (token-gesichert).  FR-5 (M): Nach Gespräch wird Report+PDF erzeugt und verlinkt; Email optional.  NFR-1 (H): Keine stillen Fallbacks; Fehler sichtbar + Request-ID + Logging.  NFR-2 (H): Security: Public Agent darf ohne Token keine Userdaten sehen.  NFR-3 (M): Reliability: Engine/Gateway Healthchecks + autostop-frei.  Testfälle (Auszug) TC-1: Engine down → /api/analysis liefert Fehler; FE ErrorCard; kein Fake Output.  TC-2: /api/symbol fail → FE zeigt Retry; kein Default-Symbol.  TC-3: RLS: User A kann User B chart nicht lesen.  TC-4: Tool get_user_context ohne gültigen session_token → 401.  TC-5: Widget sichtbar in <1s (telemetry event).  TC-6: Post-call webhook → report+pdf URLs erscheinen im Dashboard.  Traceability (FR → Tasks → Tests) FR-1 → T2.1, T2.3 → TC-1  FR-2 → T3.1, T3.2 → TC-2  FR-3 → T4.1–T4.3 → TC-3  FR-4 → T5.2–T5.3 → TC-4  FR-5 → T6.1–T6.4 → TC-6  NFR-1 → T0.2, T0.3, T2.3 → TC-1/TC-2  NFR-2 → T5.2–T5.3 → TC-4  NFR-3 → T2.2, T1.1 → (Health smoke + TC-1)  Offene Annahmen & nächste Validierung Rein subjektiv, aus meinem Denken ergibt sich, dass du für ein wirklich „mockup-free“ MVP zwei Dinge früh entscheiden solltest (auch wenn du’s später ändern kannst):  Wo läuft das Gateway (Container-Plattform bevorzugt, wenn PDF zuverlässig sein muss)?  Wie genau sieht „signed-url“ bei ElevenLabs aus (falls das Widget das unterstützt) – unabhängig davon bleibt Token-Validation im Gateway der harte Riegel.  Faktisch korrekt sage ich, welche Teile hochsicher sind: Eure aktuellen Schmerzpunkte (Widget-Race/Env-IDs, Symbol-Fallback-Kreuz, Engine-Endpoint-Mismatch/Autostop) und die daraus abgeleiteten Fix-Kategorien sind in euren Referenzen klar benannt. Logisch scheint mir, wo Unsicherheit und Annahmen liegen: genaue ElevenLabs-signed-url/Allowlist-Details und die beste Deploy-Form für PDF/Email hängen von eurer Zielplattform ab; der Plan sichert das durch Gateway-Tokenisierung und Job-Status ab. Rein subjektiv, aus meinem Denken ergibt sich, welche spekulativen Hypothesen ich angeboten habe: dass ein Container-Gateway langfristig weniger PDF-Stress macht als reine Functions, und dass Audit-Events/Jobs-Tabellen euch spürbar schneller debuggen lassen.


Elevenlabs agent widgets:
levi = <elevenlabs-convai agent-id="agent_9001kdhah7vrfh3rd05pakg8vppk"></elevenlabs-convai><script src="https://unpkg.com/@elevenlabs/convai-widget-embed" async type="text/javascript"></script>

victoria = <elevenlabs-convai agent-id="agent_1701kdekhhref78v6547amzrg1nb"></elevenlabs-convai><script src="https://unpkg.com/@elevenlabs/convai-widget-embed" async type="text/javascript"></script>

BaziEngine on fly.io: https://baziengine-v2.fly.dev
